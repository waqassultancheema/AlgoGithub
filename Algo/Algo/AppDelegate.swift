//
//  AppDelegate.swift
//  Algo
//
//  Created by Waqas Sultan on 11/19/18.
//  Copyright Â© 2018 Waqas Sultan. All rights reserved.
//

import UIKit

@UIApplicationMain


class AppDelegate: UIResponder, UIApplicationDelegate {
    
    var window: UIWindow?
    
    
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        
        //        checkUniqueString()
        //       print(algo2CheckPerumtation(firstString: "", secondString: ""))
        //        print(add20ToSpace(inputString: "Mr John Smith ", trueLength: 13))
        //        print(onwayString(inputString: "pale", secondString: "ale"))
        //       // print(laneChange(lanes: [6,2,3,2,1,3,1]))
        //        print(solution(["test1a", "test2", "test1b", "test1c", "test3"], ["Wrong answer", "OK", "Runtime error", "OK", "Time limit exceeded"]))
        //        print(solution2("ABCBBCBA"))
        //        print(longestWord(string: "We test coders. Give us a try?"))
        //        print(Alexsolution([10,19,15], 2, 2))
        
        // print(fib(9))
        // print("\n good anaser stating")
        // let string = goodAnswer(8181)
        //    let fs = string.compareTwoBigInt(right: BigInt(value: "239001090710360059034248200673 803309562195124933438825088385 870209105768309267224930066773 271004303009695857056812050426 322722227488483596969330539198 412751609689113829755775066752 844437629935556689908621747058 520170917953833076673228939285 877150494526386620300621280749 499924952199516712960736433814 553231958282333619656314497995 824452475174641352224677997408 976231194557854106641619031011 172157654286916061043356523159 334857136487352779804235483277 506977454306460042287968212874 761824582897118739286429568840 003151050106146828835563160817 912048376040050029809912293013 734791567749471727392937824065 261113177259783202662957881148 637632338195187490758787735996 699022778723575367214258563034 452504094360966531897568256418 608645465915444745840473934322 871426418866598642747848660145 342643755366760919516317387477 526541252807114293921792114970 905075434450564838742451198888 345673434700068960962172644679 947794329807611771708249033661 865248799511661306285140477533 559743999464574932871122125066 107105911374614630965320293086 278694399936369060752395531165 804412176996135810584035128447 884802662630006754418904791563 798389799016017336123177492245 220148295507234160487497059285 034564989541608419857951981398 972834439558266427410836592525 389894745439937417033358839088 886819050208294080514041113275 997534122520735761635971975621 605403703050984275628628811283 403426936742851082726036123336 764016240562071825096262121405 587203818756266733130406345518 134166312225673215071500009165 695469591411166981267241101113 735558997083171850461315680070 428706983814819412637005375477 590183910679020180492817106735 246177201410250973608332090435 177967936901320342366183865669 056306257798108871942566285065 496557591483743343454453933506"))
        //print(fs)
        
        //print(BigInt(value: "21").add(right: BigInt(value: "13")))
        
        //        var tree = BinarySearchTree.leaf(1)
        //        tree = tree.insert(2)
        //        tree = tree.insert(1)
        //        tree = tree.insert(3)
        //        tree = tree.insert(0)
        //        tree = tree.insert(7)
        //        tree = tree.insert(9)
        //        //print(tree)
        //
        //       print(tree.traverse(2))
        // getNumber(value: 610)
        // solution()
        //        let arr:[Int] = [1,2,3,4]
        //        var ans = 0
        
        
        //     print(solution("ssswwww"))
        //     print(diagonalDifference(arr: [[11,2,4],[4,5,6],[10,8,-12]]))
        //        print(plusMinus(arr: [-4, 3, -9, 0, 4, 1]))
        //        staircase(n: 4)
        //        miniMaxSum(arr: [5,5,5,5,5])
        //        print(birthdayCakeCandels(arr: [3,2,1,3]))
        //        print(timeConversion(s: "12:45:54PM"))
        //   5 2 6 11 29 12 7
        
        //    print(mandragora(H: [5,2,6,11,29,12,7]))
        // print(["e","f"].powerset)
        // print(mandragora(H: [3,2,2]))
        // print(getWays(n: 3, c: [1,2]))
        //  print(countArray(n: 11781, k: 91893, x: 18016))
        // print(isValid(coordinates: ["(90, 180)","(+90, +180)"]))
        //  print(numOfIds(pool: "888888555555555555555"))
        //  print(chooseFleets(wheels: [10,4,11]))
        //print(widestGap(n: 10, start: [1,2,5,8], finish: [2,2,6,10]))
        // print(pilesOfBoxes(boxesInPiles: [3,2,1]))
        // print(shortestSubstring(s: "bcaacbc"))
        // print(pri)
        //let v = getWaysv()
        //print(optimalPoint(magic: [3,2,5,4], dist: [2,3,4,2]))
        //print(gradingStudents(grades: [73,67,38,33]))
        //  countApplesAndOranges(s: 7, t: 10, a: 4, b: 12, apples: [2,3,-4], oranges: [3,-2,-4])
        // print(kangaroo(x1: 0, v1: 3, x2: 4, v2: 2))
        // print(breakingRecords(scores: [10,5,20,20,4,5,2,25,1]))
        //print(birthday(s: [1,2,1,3,2], d: 3, m: 2))
        //print(divisibleSumPairs(n: 6, k: 3, ar: [1,3,2,6,1,2]))
        // print(migratoryBirds(arr: [1,4,4,4,5,3]))
        //  print(dayOfProgrammer(year: 1918))
        // print(generalizedGCD(num: 5, arr: [2,3,4,5,6]))
        // print(cellCompete(states: [1,1,1,0,1,1,1,1], days: 2))
        //  print(removeObstacle(numRows: 3, numColumns: 3, lot: [[1,0,0],[1,0,0],[1,9,1]]))
        //  print(minimumTime(numOfSubFiles: 4, files: [4,8,6,12]))
        //  bonAppetit(bill: [3,10,2,9], k: 1, b: 12)
        
        //print(solution(S: "ba1", T: "1Ad"))
        // print(solutionSortedDates(dates: ["15 May 1994","5 Apr 1990","12 Dec 2001"]))
        //print(solutionArrayDuplicate(array: [1,2,3,6,5,8,2,4,5,6]))
        // print(solutionDuplicate2(X: 8, Y: 3))
        
        //  print(solutionCod(["codility1", "codility3", "codility2", "codility4b", "codility4a"], ["Wrong answer", "OK", "OK", "Time limit exceeded", "OK"]))
        // print(longBackSlice(a: [2,5,3,4,5,12]))
        // print(TripCal([7, 3, 7, 3, 1, 3, 4, 1]))
        print(ARtch([2,1,3], 2))
        return true
    }
    
    
    public func ARtch(_ A : [Int], _ S : Int) -> Int {
        let array = A
        var maxTrip = array.count
        
        for i in 0 ..< (A.count) {
            var tempsNumberOfTrips = array
            for i in 0 ..< (array.count) {
                let maxChunks = tempsNumberOfTrips.chunked(into: maxTrip)
                for maxchunk in maxChunks {
                    let values = maxchunk.reduce(0, +)
                    if (values / maxchunk.count) == S {
                        return maxchunk.count
                    }
                }
                tempsNumberOfTrips.remove(at: 0)
                
            }
            maxTrip = maxTrip - 1

        }
        
        return 0
    }
    
    
    public func TripCal(_ A :[Int]) -> Int {
        let numberOfTrips = A
        let totalTrips = Array(Set(numberOfTrips)).sorted()
        
        
        for i in 0 ..< (A.count) {
            let maxTrip = totalTrips.count + (i)
            var tempsNumberOfTrips = numberOfTrips
            for i in 0 ..< (numberOfTrips.count) {
                let maxChunks = tempsNumberOfTrips.chunked(into: maxTrip)
                for maxchunk in maxChunks {
                    if Array(Set(maxchunk)).sorted() == totalTrips {
                        return maxTrip
                    }
                }
                tempsNumberOfTrips.remove(at: 0)
            }
        }
        
        return  0
    }
    
    func solutionCod(_ T : [String], _ R :[String]) -> Int {
        
        let testCases  = T
        let results = R
        var testCaseresults: [Int : String] = [:]
        
        for (index, testcase) in testCases.enumerated() {
            let testCaseNo =  Int(testcase.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()) ?? 0
            if testCaseresults[testCaseNo] != "Wrong answer" &&   testCaseresults[testCaseNo] != "Runtime error" &&  testCaseresults[testCaseNo] !=  "Time limit exceeded" {
                testCaseresults[testCaseNo] =  results[index]
            }
        }
        
        var totalResult = 0
        
        for value in Array(testCaseresults.values) {
            if value == "OK" {
                totalResult = totalResult + 1
            }
        }
        
        let finalResult = (100 * totalResult ) / Array(testCaseresults.values).count
        
        return finalResult
    }
    
    
    func longBackSlice(a:[Int]) -> Int {
        
        var totalCount = 0
        var startIndex = 0
        for value in a {
            var biValuedFAlse = false
            var secondValue = -1
            var ifAlreadyUpdated = false
            for i in (startIndex+1) ..< (a.count) {
                if value != a[i] && secondValue == -1 {
                    secondValue = a[i]
                } else if value != secondValue && value != a[i] && secondValue != a[i] {
                    startIndex = i
                    biValuedFAlse = true
                    break
                } else if secondValue ==  a[i] {
                    totalCount = totalCount + 1
                    ifAlreadyUpdated = true
                }
            }
            //startIndex = startIndex + 1
            if biValuedFAlse == false && ifAlreadyUpdated == false {
                totalCount = totalCount + 1
                
            }
        }
        if totalCount > a.count {
            return a.count
        }
        
        return totalCount
    }
    
    func solution123(a: [Int]) -> Int {
        var evenIndexVal = 0
        var oddIndexVal = 0
        
        if a.count <= 2 {
            return a.count
        }
        
        var maxSwitchArrCount: Int = 0
        var switchArrCount: Int = 0
        
        var evenMismatch: Bool = false
        var oddMismatch: Bool = false
        
        for i in 0 ..< (a.count) {
            
            if i%2 == 0 {
                // Even index
                if i == 0 {
                    evenIndexVal = a[0]
                    switchArrCount += 1
                    
                } else if evenIndexVal == a[i] {
                    switchArrCount += 1
                    
                } else {
                    evenIndexVal = a[i]
                    evenMismatch = true
                }
                
            } else {
                // odd index
                
                if i == 1 {
                    oddIndexVal = a[i]
                    switchArrCount += 1
                    
                } else if oddIndexVal == a[i] {
                    switchArrCount += 1
                    
                } else {
                    oddIndexVal = a[i]
                    oddMismatch = true
                }
            }
            
            if evenMismatch && oddMismatch {
                switchArrCount = 0
                evenMismatch = false
                oddMismatch = false
            }
            
            if switchArrCount > maxSwitchArrCount {
                maxSwitchArrCount = switchArrCount
            }
            
        }
        
        return maxSwitchArrCount
    }
    func countBigBurgerAndSmallBurger(tomotoas:Int,cheese:Int) -> [Int] {
        
        var bigBurger = 0
        var smallBurger = 0
        
        for index in stride(from: 0, to:(cheese + 1), by: 1) {
            
            let value = tomotoas - (index * 4)
            let divideValue =  value/2
            if divideValue + index == cheese {
                smallBurger = divideValue
                bigBurger = index
            }
        }
        
        return [smallBurger,bigBurger]
    }
    
    
    func solutionDuplicate2(X : Int, Y : Int) ->(Int, Int){
        let numberOfTomatos  = X
        let numberOfCheese = Y
        
        if numberOfTomatos / 2  == numberOfCheese {
            return (numberOfTomatos / 2, 0)
        }else if numberOfTomatos / 2  > numberOfCheese {
            let howmuchBig : Int = numberOfTomatos / 2 - numberOfCheese
            let howmuchMini : Int = (numberOfTomatos - (howmuchBig * 4)) / 2
            
            if (howmuchBig * 4 + howmuchMini * 2) !=  numberOfTomatos || (howmuchMini + howmuchBig  != numberOfCheese) || howmuchMini < 0 || howmuchBig < 0 {
                return (-1,-1)
            }
            
            return ( howmuchMini,howmuchBig)
            
            
            
        } else {
            return (-1,-1)
        }
        
        
        
        
    }
    
    func solutionArrayDuplicate(array:[Int]) -> [Int]{
        
        var dictionaryCount = [Int:Int]()
        var totalCompleted = [Int]()
        for value in array {
            if let dicValue = dictionaryCount[value] {
                dictionaryCount[value] = dicValue + 1
                totalCompleted.removeAll(where: { $0 == value })
                
            } else {
                dictionaryCount[value] = 1
                if totalCompleted.contains(value) == false {
                    totalCompleted.append(value)
                }
                
            }
        }
        let finalArray = [totalCompleted[0],totalCompleted[1]]
        return finalArray
    }
    
    func solutionSortedDates(dates:[String]) -> [String] {
        
        
        var finalArray = [String]()
        
        
        var dictionaryOFYear:[String:[String:[String]]] = [String:[String:[String]]]()
        
        for date in dates {
            let firstDateComponent = date.components(separatedBy: " ")
            var monthsDictionary = ["Jan":[],"Feb":[],"Mar":[],"Apr":[],"May":[],"June":[],"July":[],"Aug":[],"Sept":[],"Oct":[],"Nov":[],"Dec":[]]
            var array =  monthsDictionary[firstDateComponent[1]]
            array?.append(firstDateComponent.first)
            monthsDictionary[firstDateComponent[1]] = array
            dictionaryOFYear["\(firstDateComponent.last!)"] = monthsDictionary as? [String : [String]]
        }
        
        let sortedYearKeys = Array(dictionaryOFYear.keys).sorted()
        
        for year in sortedYearKeys {
            let dictionary = dictionaryOFYear[year]
            let sortedMonthKeys = Array(dictionary!.keys).sorted()
            for month in sortedMonthKeys {
                let daysArray = dictionary![month]
                if  daysArray!.count > 0 {
                    let datesSorted = daysArray!.sorted()
                    for date in datesSorted {
                        if Int(date)! > 0 {
                            let finalString = "\(date) \(month) \(year)"
                            finalArray.append(finalString)
                        }
                    }
                }
            }
            
        }
        
        return finalArray
    }
    
    func solution(S:String,T:String) ->Bool {
        var finalString = ""
        
        var string1 =  [String]()
        var string2 = [String]()
        
        func returnDecodeValue(str:String) -> String {
            var string1 = ""
            for char in str {
                if let value  =  char.wholeNumberValue {
                    for _ in stride(from: 0, to:value, by: 1) {
                        string1 = string1 + "?"
                    }
                } else {
                    string1 = string1 + "\(char)"
                }
            }
            
            return string1
        }
        if S.count != T.count {
            return false
        } else {
            let sss  = returnDecodeValue(str: S)
            let sddd = returnDecodeValue(str: T)
            
            string1 = sss.map{String($0)}
            string2 =  sddd.map{String($0)}
            for index in stride(from: 0, to:string1.count, by: 1) {
                
                if string1[index] == "?" && string2[index] != "?" {
                    finalString = finalString + string2[index]
                } else if string1[index] != "?" && string2[index] == "?" {
                    finalString = finalString + string1[index]
                } else {
                    finalString = finalString + string1[index] //both miss match
                }
                
            }
            var isAllMatch = true
            
            for index in stride(from: 0, to:finalString.count, by: 1) {
                
                if finalString[index] != "?" && (string2[index] != finalString[index] && string2[index] != "?" )   || ( string1[index] != finalString[index] && string1[index] != "?") {
                    isAllMatch = false
                }
                
            }
            
            return isAllMatch
            
            
            
        }
        
        return true
        
    }
    func bonAppetit(bill: [Int], k: Int, b: Int) -> Void {
        
        var total = bill.reduce(0, +)
        
        total  = total - bill[k]
        
        if (total/2) == b {
            print("Bon Appetit")
        } else {
            let share = total/2
            let diff = share - b
            
            print(abs(diff))
        }
        
        
        
    }
    func minimumTime(numOfSubFiles:Int, files:[Int]) -> Int
    {
        
        return 0
    }
    func removeObstacle(numRows:Int, numColumns:Int, lot:[[Int]]) -> Int
    {
        // WRITE YOUR CODE HERE
        var distance = [[Int]]()
        
        for _ in stride(from: 0, to: numRows, by: 1) {
            var arr = [Int]()
            for _ in stride(from: 0, to: numColumns, by: 1) {
                arr.append(-1)
            }
            distance.append(arr)
        }
        
        for indeX in stride(from: 0, to: numRows, by: 1) {
            
            for indexY in stride(from: 0, to: numColumns, by: 1) {
                if distance[indeX][indexY] == -1 {
                    if lot[indeX][indexY] != 0 {
                        distance[indeX][indexY] = distance[indeX][indexY] + 1
                    }
                }
            }
        }
        
        
        
        return -1
    }
    func cellCompete(states:[Int],days:Int) -> [Int] {
        
        var array = [Int]()
        var pervIndex = -1
        var nextIndex = 1
        var Estates:[Int] = states
        for _ in stride(from: 0, to: days, by: 1) {
            pervIndex = -1
            nextIndex = 1
            array.removeAll()
            for _ in Estates {
                if nextIndex > states.count {
                    break
                }
                if pervIndex == -1 {
                    if Estates[nextIndex] == 0 {
                        array.append(0)
                    } else {
                        array.append(1)
                    }
                } else if nextIndex >= Estates.count {
                    if Estates[pervIndex] == 0 {
                        array.append(0)
                    } else {
                        array.append(1)
                    }
                }
                else if Estates[pervIndex] == Estates[nextIndex] {
                    array.append(0)
                } else {
                    array.append(1)
                }
                
                pervIndex = pervIndex + 1
                nextIndex = nextIndex + 1
                
                
            }
            Estates = array
        }
        
        return array
    }
    func generalizedGCD(num:Int, arr:[Int]) -> Int {
        
        let arra = arr.sorted()
        var largestValue = 1
        for index in stride(from: 0, to: num, by: 1) {
            let value = arra[index]
            var isGCD = true
            for item in arra {
                if item % value != 0 {
                    isGCD = false
                    break
                }
            }
            if isGCD == true {
                largestValue = value
            }
            
        }
        
        return largestValue
    }
    
    func dayOfProgrammer(year: Int) -> String {
        
        var febmonth = 28
        if year > 1918 {
            if (year % 4 == 0 && year % 100 != 0 ) || (year % 400 == 0) {
                febmonth = 29
            } else {
                febmonth  = 28
            }
        } else {
            if year % 4 == 0  {
                febmonth = 29
            } else {
                febmonth  = 28
            }
        }
        
        let daysinYears = [31,febmonth,31,30,31,30,31,31,30,31,30,31]
        var totalAdd = 0
        var monthYear = 0
        for item in daysinYears {
            
            let value = totalAdd + item
            if value  < 256 {
                totalAdd = value
            } else {
                break
            }
            monthYear = monthYear + 1
        }
        monthYear = monthYear + 1
        
        
        if monthYear < 10 {
            return "\(256 - totalAdd).0\(monthYear).\(year)"
            
        }
        return "\(256 - totalAdd).\(monthYear).\(year)"
        
    }
    
    func migratoryBirds(arr: [Int]) -> Int {
        
        
        var dictionary:[Int:Int]  = Dictionary()
        
        for item in arr {
            if let value = dictionary[item] {
                dictionary[item] = value + 1
            } else {
                dictionary[item] = 1
            }
        }
        
        let maxValue = dictionary.values.max() ?? 0
        
        let key = dictionary.allKeysForValue(val: maxValue)
        
        if key.count > 1 {
            let sortedKey = key.sorted()
            if let firstKey = sortedKey.first {
                return firstKey
            }
        } else if key.count == 1 {
            if let firstKey = key.first {
                return firstKey
            }
        }
        
        return 0
        
    }
    
    
    func divisibleSumPairs(n: Int, k: Int, ar: [Int]) -> Int {
        
        var totalSets  = 0
        
        var firstIndex  = 0
        var secondIndex = 0
        while firstIndex < ar.count {
            let value  = ar[firstIndex]
            secondIndex = secondIndex + 1
            if firstIndex < secondIndex {
                for index in stride(from: secondIndex, to: ar.count, by: 1) {
                    let secondValue = ar[index]
                    if (value + secondValue) % k  == 0 {
                        totalSets = totalSets + 1
                    }
                }
            }
            firstIndex = firstIndex  + 1
            
        }
        
        return totalSets
    }
    func birthday(s: [Int], d: Int, m: Int) -> Int {
        
        var totalP = 0
        var currentIndex  = 0
        var currentRound = 0
        var currentTotalSum = 0
        for value in s {
            currentIndex = currentIndex + 1
            currentRound  = 1
            currentTotalSum = value
            for index in stride(from: currentIndex, to: s.count, by: 1)  {
                if currentRound < m {
                    currentTotalSum = currentTotalSum + s[index]
                    currentRound = currentRound  + 1
                } else {
                    break
                }
            }
            
            if (currentTotalSum) == d {
                totalP = totalP + 1
            }
        }
        
        return totalP
        
    }
    func breakingRecords(scores: [Int]) -> [Int] {
        
        var lowestScroe  = scores.first ?? 0
        var highestScrore = scores.first ?? 0
        var totalChangeinLowest = 0
        var totalChangesinHigh = 0
        
        for score in scores {
            if lowestScroe > score {
                lowestScroe = score
                totalChangeinLowest = totalChangeinLowest + 1
            }
            if highestScrore < score {
                highestScrore = score
                totalChangesinHigh = totalChangesinHigh + 1
                
            }
        }
        
        return [totalChangesinHigh,totalChangeinLowest]
    }
    func getTotalX(a: [Int], b: [Int]) -> Int {
        var allElementsAreMultiple = false
        var numberIsMultipleOfAll  = false
        
        let minB = b.reduce(b[0], min)
        
        var total = 0
        
        for i in 1...minB {
            
            let ac = a.map { return i % $0 == 0 }
            let bc = b.map { return $0 % i == 0 }
            allElementsAreMultiple = ac.reduce(true, {$0 && $1})
            numberIsMultipleOfAll  = bc.reduce(true, {$0 && $1})
            
            if (allElementsAreMultiple && numberIsMultipleOfAll)
            {
                total += 1
            }
        }
        
        return total
        
    }
    
    func kangaroo(x1: Int, v1: Int, x2: Int, v2: Int) -> String {
        
        var currentLocationforKangro1 = x1
        var currentLocationForKangro2 = x2
        
        for _ in stride(from: 0, to: 10001, by: 1)  {
            
            currentLocationforKangro1 = currentLocationforKangro1 + v1
            currentLocationForKangro2  =  currentLocationForKangro2 + v2
            
            if currentLocationforKangro1 == currentLocationForKangro2  {
                return "YES"
            }
        }
        return "NO"
    }
    
    func countApplesAndOranges(s: Int, t: Int, a: Int, b: Int, apples: [Int], oranges: [Int]) -> Void {
        
        
        var appleCount = 0
        var orrangeCount = 0
        
        for apple in apples {
            let value = a + apple
            if value >= s && value <= t {
                appleCount = appleCount + 1
            }
        }
        
        for orange in oranges {
            let value = b + orange
            if value >= s && value <= t {
                orrangeCount = orrangeCount + 1
            }
        }
        print(appleCount)
        print(orrangeCount)
        
    }
    func roundOf5(value : Int) -> Int {
        let a = (value / 5) * 5
        let b = a + 5
        return (b - value) >= 3 ? value : b
    }
    func gradingStudents(grades: [Int]) -> [Int] {
        // Write your code here
        
        var gradeCopy = [Int]()
        
        for grade in grades {
            let value = roundOf5(value: grade)
            if value < 40 {
                gradeCopy.append(grade)
            } else if value >= 40 {
                if grade % 5 == 0 {
                    gradeCopy.append(grade)
                } else if value - grade < 3 {
                    gradeCopy.append(roundOf5(value: grade))
                } else {
                    gradeCopy.append(grade)
                }
            }
        }
        return gradeCopy
        
    }
    func optimalPoint(magic: [Int], dist: [Int]) ->Int {
        
        var visitedDistance = [Bool](repeating: false, count: dist.count)
        var visitedMagic = [Bool](repeating: false, count: magic.count)
        
        let maxvalue = magic.max()
        var indexOfmagic = 0
        var index = 0
        for value in magic {
            if value == maxvalue {
                indexOfmagic = index
                visitedMagic[indexOfmagic] = true
                index = index + 1
                break
            }
            index = index + 1
        }
        var currentPoints = maxvalue ?? 0
        var comingForSecondTime = false
        var visitedAgain = indexOfmagic
        while true {
            indexOfmagic = indexOfmagic + 1
            if comingForSecondTime == true && visitedAgain < indexOfmagic {
                break
            }
            if index >= dist.count{
                index = 0
            }
            if indexOfmagic >= magic.count && comingForSecondTime == false {
                indexOfmagic = 0
                comingForSecondTime = true
                
            }
            if visitedDistance[index] == false {
                visitedDistance[index] = true
                
                if visitedMagic[indexOfmagic] == false {
                    visitedMagic[indexOfmagic] = true
                    currentPoints = currentPoints - dist[index] + magic[indexOfmagic]
                } else {
                    currentPoints = currentPoints - dist[index]
                }
                
            }
            index = index + 1
        }
        return currentPoints
    }
    
    func priceCheck(products: [String], productPrices: [Float], productSold: [String], soldPrice: [Float]) {
        
        var orignalprice = productPrices
        var items = products
        var itemSold = productSold
        
        var dictionary:[String:Float]  = Dictionary()
        var numberOferrrors = 0
        for index in stride(from: 0, to: items.count, by: 1)  {
            dictionary[items[index]] = orignalprice[index]
        }
        
        for index in stride(from: 0, to: itemSold.count, by: 1)  {
            if let value = dictionary[itemSold[index]] {
                let diff = value  - soldPrice[index]
                if diff != 0 {
                    numberOferrrors = numberOferrrors + 1
                }
            }
        }
        print(numberOferrrors)
    }
    
    func shortestSubstring(s: String) -> Int {
        
        var visited = [Bool](repeating: false, count: 256)
        var distanceCount  = 0
        for value in s {
            let asi:Int = Int("\(value.ascii ?? 0)") ?? 0
            if visited[asi] == false {
                visited[asi]  = true
                distanceCount = distanceCount + 1
            }
        }
        
        var currentCount = [Int](repeating: 0, count: 256)
        var count = 0
        
        var start = 0
        var start_index = -1
        var currentINdex = 0
        var min_len = Int.max
        for value in s {
            let asi:Int = Int("\(value.ascii ?? 0)") ?? 0
            currentCount[asi] = currentCount[asi] + 1
            
            if currentCount[asi] == 1 {
                count =  count + 1
            }
            if count == distanceCount {
                
                var character = Character(s[start])
                var assic = s.ascii[start]
                
                var charcaterSTartAss:Int = Int("\(assic ?? 0)") ?? 0
                
                while currentCount[charcaterSTartAss] > 1 {
                    
                    if currentCount[charcaterSTartAss] > 1 {
                        currentCount[charcaterSTartAss] = currentCount[charcaterSTartAss] - 1
                        start = start + 1
                        assic = s.ascii[start]
                        // character = s.characters[start]//Character(s[start])
                        charcaterSTartAss = Int("\(assic ?? 0)") ?? 0
                    }
                }
                
                var length_Window = currentINdex - start + 1
                if min_len > length_Window {
                    min_len = length_Window
                    start_index = start
                }
                
            }
            
            currentINdex = currentINdex + 1
        }
        
        let toLeng = (start_index + min_len)
        let subString = s[start_index..<toLeng]
        return subString.count
    }
    func getSecondBestInArray(_ array:[Int]) -> Int {
        
        let max = array.max()
        
        for item in array {
            if item != max {
                return item
            }
        }
        return 0
    }
    func getUpdatedArry(maxElement:Int,secondBest:Int,array:[Int]) -> [Int] {
        
        var arr = array
        for index in stride(from: 0, to: array.count, by: 1)  {
            
            if arr[index] == maxElement {
                arr[index] = maxElement - (maxElement - secondBest)
                break
            }
        }
        return arr
    }
    
    func secondFunction(sortedArray:[Int],totalSteps:Int)-> Int{
        
        var totalSteps = totalSteps
        var sortedArray = sortedArray.sorted(by:>)
        let maxElement = sortedArray.max() ?? 0
        let minElement  = sortedArray.min() ?? 0
        if maxElement == minElement {
            return totalSteps
        }
        let secondBest = getSecondBestInArray(sortedArray)
        for index in stride(from: 0, to: sortedArray.count, by: 1)  {
            
            if sortedArray[index] == maxElement {
                sortedArray[index] = maxElement - (maxElement - secondBest)
                totalSteps = totalSteps + 1
            }
        }
        return totalSteps
    }
    func pilesOfBoxes(boxesInPiles: [Int]) -> Int {
        // Write your code here
        
        var sortedArray = boxesInPiles.sorted(by: >)
        
        var totalSteps = 0
        var maxElement = sortedArray.max() ?? 0
        var minElement  = sortedArray.min() ?? 0
        var secondBest = getSecondBestInArray(sortedArray)
        var ins = 0
        for  _ in stride(from: 0, to: sortedArray.count, by: 1)  {
            
            if sortedArray[ins] == maxElement {
                sortedArray[ins] = maxElement - (maxElement - secondBest)
                totalSteps = totalSteps + 1
            }
            if maxElement != sortedArray.max() {
                ins = 0
                // sortedArray = sortedArray.sorted(by:>)
                maxElement = sortedArray.max() ?? 0
                minElement  = sortedArray.min() ?? 0
                secondBest = getSecondBestInArray(sortedArray)
                
                if maxElement == minElement {
                    break
                }
            } else {
                ins = ins + 1
            }
            
        }
        
        return totalSteps
    }
    
    
    func widestGap(n: Int, start: [Int], finish: [Int]) -> Int {
        
        var array = [String]()
        
        for _ in stride(from: 0, to: n, by: 1)  {
            array.append("green")
        }
        
        for index in stride(from: 0, to: start.count, by: 1)  {
            
            for ind in stride(from: start[index], to: finish[index]+1, by: 1) {
                array[ind - 1] = "red"
            }
        }
        
        var widestGapArray = [Int]()
        for var index in stride(from: 0, to: n, by: 1)  {
            var widestGap = 0
            if index >= widestGapArray.count {
                if array[index] == "green" {
                    for ind in stride(from: index, to: n, by: 1)  {
                        if array[ind] == "green" {
                            widestGap = widestGap + 1
                            index = index + 1
                        } else {
                            break
                        }
                    }
                }
                widestGapArray.append(widestGap)
            }
        }
        
        return widestGapArray.max() ?? 0
        
    }
    
    func chooseFleets(wheels: [Int]) -> [Int] {
        
        //6,3,2
        var totalNumberOFWays = Array<Int>()
        for current in wheels {
            var totalWays = 0
            if current % 2 == 0 {
                totalWays = totalWays  + 1
                
                
            }
            if current % 2  == 0 && current % 4 != 0 && current > 4 {
                let leftValue = current % 4
                if leftValue % 2 == 0 {
                    totalWays = totalWays + 1
                }
                
                let remaing = current - 4
                
                if remaing % 2  == 0 && remaing != leftValue{
                    totalWays = totalWays + 1
                    
                }
            } else if current % 4 == 0 {
                totalWays = totalWays + 1
            }
            
            totalNumberOFWays.append(totalWays)
            
        }
        
        return totalNumberOFWays
    }
    
    func numOfIds(pool: String) -> Int {
        
        
        var totalNoOfId = 0
        
        var totalCount = 0
        var countHasStarted = false
        for chr in pool {
            if totalCount == 11 {
                totalNoOfId = totalNoOfId + 1
                countHasStarted = false
                totalCount = 0
            }
            if chr == "8" && countHasStarted == false {
                countHasStarted = true
                totalCount = totalCount + 1
            } else if countHasStarted == true && totalCount < 12 {
                totalCount = totalCount + 1
            } else {
                
            }
        }
        
        return totalNoOfId
    }
    func isValid(coordinates: [String]) -> Void {
        
        let regex = "\\([+-]?(90(\\.0+)?|([1-8][0-9]|[1-9])(\\.\\d+)?), [+-]?(180(\\.0+)?|(1[0-7][0-9]|[1-9][0-9]|[1-9])(\\.\\d+)?)\\)"
        
        let regexFormatter = try! NSRegularExpression(pattern: regex, options: .dotMatchesLineSeparators)
        
        for text in coordinates {
            let matches = regexFormatter.matches(in: text, options: [], range: NSRange(location: 0, length: text.count))
            if (matches.count == 0) {
                print("InValid")
            }
            else {
                print("Valid")
            }
        }
        //        var pattern = ""      //  let regex = NSRegularExpression(#"/\(([-+]?([1-8]?\d(\.\d+)?|90(\.0+)?)),\s([-+]?((1[0-7]\d|[1-9]?\d)(\.\d+)?)|[-+]?180(\.0+)?)\)/g)"#)
        //
        //        let x = "\\([-+]?(([1-8]?\\d)(\\.\\d+)?|90(\\.0+)?)"
        //        let y = "[-+]?(([1-9]?\\d|1[0-7]\\d)(\\.\\d+)?|180(\\.0+)?)\\)"
        //        for coor in coordinates {
        //
        //            if let value = coor.range(of: "\(x) \(y)") {
        //
        //            }
        //
        //        }
    }
    
    //    func closestStraightCity(c: [String], x: [Int], y: [Int], q: [String]) -> [String] {
    //
    //
    //
    //    }
    
    func combos<T>(elements: ArraySlice<T>, k: Int) -> [[T]] {
        if k == 0 {
            return [[]]
        }
        
        guard let first = elements.first else {
            return []
        }
        
        let head = [first]
        let subcombos = combos(elements: elements, k: k - 1)
        var ret = subcombos.map { head + $0 }
        ret += combos(elements: elements.dropFirst(), k: k)
        
        return ret
    }
    
    func combos<T>(elements: Array<T>, k: Int) -> [[T]] {
        return combos(elements: ArraySlice(elements), k: k)
    }
    func sliceArray<T>(_ arr: Array<T>, _ x1: Int, _ x2: Int) -> Array<T> {
        
        var tt: Array<T> = []
        
        for index in stride(from: x1, to: (x2+1), by: 1) {
            tt.append(arr[index])
        }
        
        
        return tt
        
    }
    func combinations<T>(_ arr: Array<T>,_ k: Int) -> Array<Array<T>> {
        
        
        var ret: Array<Array<T>> = []
        
        var sub: Array<Array<T>> = []
        
        var next: Array<T> = []
        
        for i in stride(from: 0, to: arr.count, by: 1) {
            if(k == 1){
                
                ret.append([arr[i]])
                
            }else {
                let sliceElement =  sliceArray(arr, i + 1, arr.count - 1)
                
                sub =   combinations(sliceElement, k - 1)
                
                for index in stride(from: 0, to: sub.count, by: 1) {
                    next = sub[index]
                    
                    next.insert(arr[i], at: 0)
                    
                    ret.append(next)
                }
                
                
            }
        }
        
        
        return ret
        
    }
    
    func countArray(n: Int, k: Int, x: Int) -> Int {
        
        
        
        var makeCombinationArray = Array<Int64>()
        
        for index in stride(from: 1, to: (k+1), by: 1) {
            makeCombinationArray.append(Int64(index))
        }
        
        let combinations = makeCombinationArray.combinations(makeCombinationArray, n - 2)
        
        var totalPossibleArrays = Array<Array<Int64>>()
        for combination in combinations {
            
            var array:Array = Array<Int64>()
            for _ in 0..<(n) {
                array.append(-1)
            }
            array[0] = 1
            array[n - 1] = Int64(x)
            
            for element in combination {
                
                
                for index in stride(from: 1, to: n - 1, by: 1) {
                    if index != 0  && index != (n - 1) {
                        if index == 1  && array[0] != element {
                            if  array[index]  == -1 && index < n {
                                array[index] = element
                            }
                        } else  if  ((n - 2 == index && array[ n - 1] != element) ) {
                            
                            if  array[index]  == -1 && index < n {
                                array[index] = element
                            }
                        }  else if array[index - 1] != element && array[index + 1] != element {
                            
                            // index != 1 && n - 1 != index
                            if  array[index]  == -1 && index < n {
                                array[index] = element
                            }
                        }
                        
                        
                    } else {
                    }
                }
                
                
            }
            print(array)
            totalPossibleArrays.append(array)
        }
        
        
        
        return totalPossibleArrays.count
        
    }
    
    
    func getWays(n: Int, c: [Int]) -> Int {
        
        let coins = c
        let totalChange = n
        var table:Array = Array<Array<Int>>()
        var calculated:Array = Array<Array<Bool>>()
        for _ in 0..<53 {
            var arrayBool = Array<Bool>()
            var intArray = Array<Int>()
            for _ in 0..<253 {
                arrayBool.append(false)
                intArray.append(0)
            }
            calculated.append(arrayBool)
            table.append(intArray)
        }
        
        func solve(_ i:Int,_ make:Int) -> Int {
            
            if make < 0 {
                return 0
            }
            
            if make == 0 {
                return 1
            }
            if i >= coins.count {
                return 0
            }
            
            if  calculated[i].count < make || calculated[i][make] == false {
                let leftSide  = solve(i, make - coins[i])
                let rightSide = solve(i + 1, make)
                table[i][make] = leftSide +  rightSide
                calculated[i][make] = true
            }
            
            
            return table[i][make]
        }
        
        return solve(0, totalChange)
        
    }
    
    
    func mandragora(H: [Int]) -> Int {
        
        var array = H
        array = array.sorted()
        var health =  1
        var totalSum = 0
        for element in array {
            totalSum =  element  + totalSum
        }
        
        
        var battlePoint = totalSum
        for currentMandr in array {
            health = health  + 1
            totalSum = totalSum - currentMandr
            var currentScrore = totalSum * health
            
            if currentScrore > battlePoint {
                battlePoint =  currentScrore
            }
        }
        
        return battlePoint
        
    }
    
    func timeConversion(s:String) -> String {
        
        var string  = s
        if let j = string.index(of: "M") {
            string.remove(at: j)
        }
        if string.contains("P") {
            if let i = string.index(of: "P") {
                string.remove(at: i)
            }
            let stringArray  =  string.components(separatedBy: ":")
            let firstComponeent = stringArray.first ?? "0"
            
            var hour24  = (Int(firstComponeent) ?? 0) + 12
            
            if firstComponeent == "12" {
                hour24 = 12
            }
            
            if hour24 > 9 {
                return "\(hour24):\(stringArray[1]):\(stringArray[2])"
            } else {
                return "0\(hour24):\(stringArray[1]):\(stringArray[2])"
            }
            
        } else {
            if let i = string.index(of: "A") {
                string.remove(at: i)
            }
            let stringArray  =  string.components(separatedBy: ":")
            let firstComponeent = stringArray.first ?? "0"
            let hour24  = (Int(firstComponeent) ?? 0)
            if hour24 == 12 {
                return "00:\(stringArray[1]):\(stringArray[2])"
            }
            
            return string
        }
    }
    func birthdayCakeCandels(arr:[Int]) -> Int {
        let maxValue  = arr.max()
        var totalMAx = 0
        
        for item in arr {
            if item == maxValue {
                totalMAx = totalMAx + 1
            }
        }
        
        
        return totalMAx
        
    }
    func miniMaxSum(arr:[Int]) {
        
        let minValue = arr.min()
        let maxValue  = arr.max()
        
        var minSum = 0
        var maxSum = 0
        for item in arr {
            if maxValue == minValue {
                maxSum = item * (arr.count - 1)
                minSum = maxSum
                break
            } else {
                
                if item != minValue {
                    maxSum = item + maxSum
                }
                if item != maxValue {
                    minSum = item + minSum
                }
                
            }
        }
        print("\(minSum) \(maxSum)")
    }
    
    func staircase(n:Int) -> Void {
        
        
        
        for index in stride(from: 0, to: n, by: 1) {
            var tabString = ""
            let value = (n - index)
            for _ in stride(from: 1, to: value, by: 1) {
                tabString = " " + tabString
                
            }
            
            for _ in stride(from: value, to: (n+1), by: 1) {
                tabString =  tabString + "#"
            }
            print(tabString)
            
            
        }
    }
    func plusMinus(arr: [Int]) -> Void {
        
        var positiveNOCount = 0
        var negativeCount = 0
        var zeroCount = 0
        for item in arr {
            
            if item > 0 {
                positiveNOCount = positiveNOCount + 1
            } else if item == 0 {
                zeroCount = zeroCount + 1
            } else {
                negativeCount = negativeCount + 1
                
            }
        }
        
        print(Float(Float(positiveNOCount)/Float(arr.count)))
        print(Float(Float(negativeCount)/Float(arr.count)))
        print(Float(Float(zeroCount)/Float(arr.count)))
        
        
        
    }
    func diagonalDifference(arr: [[Int]]) -> Int {
        
        let filterAray = arr.filter { (item) -> Bool in
            
            return true
        }
        var revIndex = filterAray.count - 1
        var firstDiag = 0
        var secondDiag = 0
        for index in stride(from: 0, to: filterAray.count, by: 1) {
            
            firstDiag = firstDiag + filterAray[index][index]
            secondDiag = secondDiag + filterAray[index][revIndex]
            
            
            revIndex = revIndex - 1
        }
        
        let ans = abs(firstDiag - secondDiag)
        
        return ans
    }
    func compareTriplets(ar: [Int]) -> Int {
        
        var pointsEarned:Int = 0
        let val = 0
        for element in ar {
            pointsEarned =  element  + pointsEarned
        }
        
        return pointsEarned
        
    }
    
    func ord (_ s : String) -> Int {
        return Int(s.utf16[s.utf16.startIndex]);
    }
    
    func ord (_ c : Character) -> Int {
        return ord(String(c));
    }
    
    public func solution(_ S: String) -> String {
        let S_characters = Array(S);
        var occurrences = [Int](repeating: 0, count: 26);
        
        for i in 0...(S_characters.count - 1) {
            occurrences[ord(S_characters[i]) - ord("a")] += 1;
        }
        
        var best_char: Character = "a";
        var best_res: Int = 0;
        let maxValue = occurrences.max()
        
        let indexOfMax = occurrences.indices.filter { occurrences[$0] == maxValue }
        let maxIndex = indexOfMax.first ?? 0
        return String(Character(UnicodeScalar(ord("a") + maxIndex)!))
        for i in 1...25 {
            if (occurrences[i] >= best_res) {
                best_char = Character(UnicodeScalar(ord("a") + i)!);
                best_res = occurrences[i];
            }
        }
        
        return String(best_char);
    }
    
    func solution() -> Int {
        let A = 53
        let B = 1953786
        
        let string = "\(B)"
        let stringB = "\(A)"
        let array = stringB.compactMap{String($0)} // [1, 2, 3, 4, 5, 6]
        var position = 0
        var positofoudn = -1
        for element in string {
            if positofoudn != -1 {
                if "\(element)" == array.first {
                    break
                }
            }
            if "\(element)" == array.first {
                positofoudn = position
            }
            position  = position + 1
        }
        
        return positofoudn
    }
    
    func getNumber(value:Int) -> Int {
        
        var  ways:UInt64 = 0
        
        var first:UInt64 = 0
        var second:UInt64 = 0
        var third:UInt64 = 0
        var fourth:UInt64 = 0
        var fifth:UInt64 = 0
        var sixth:UInt64 = 1
        
        for i in stride(from: 0, to: value, by: 1) {
            
            ways = first + second + third + fourth + fifth + sixth
            
            if (i>0) {
                first = second;
                second = third;
                third = fourth;
                fourth = fifth;
                fifth = sixth;
                sixth = ways;
            }
            print("Ways \(i) -> \(ways)")
        }
        
        return 0
    }
    //execute breadth-first search
    
    func goodAnswer(_ elemeent: Int) -> BigInt {
        
        var  fibans:[BigInt] = [BigInt(value: "0"),BigInt(value: "1")]
        
        if(elemeent > fibans.count) {
            for i in stride(from: fibans.count, to: elemeent + 1, by: 1) {
                print()
                
                
                //    if fibans[i - 1] < UInt64.max &&  fibans[i - 2] < UInt64.max {
                let firstEle:BigInt = fibans[i - 1]
                let secondEle:BigInt = fibans[i - 2]
                let eleme:BigInt = firstEle.add(right: secondEle)
                fibans.append(eleme)
                //      } else {
                print("rpvdfd")
                //      }
                // prints from 0 to 9
            }
            
        }
        return fibans[elemeent]
    }
    
    func fib(_ element:Int) -> Int {
        
        //    print(element)
        if element <= 1 {
            return element;
        }
        return (fib(element - 1) + fib(element - 2))
        
    }
    
    
    
    
    
    
    
    
    func Alexsolution(_ A : [Int], _ K : Int, _ L : Int) -> Int {
        
        let array = A
        let alex = K
        let bob = L
        
        var alexIndex = (array.count) - (alex + bob) - 1
        if alexIndex < 1 {
            return -1
        }
        // let bobIndex = array.index(of: bob)
        var alextTotalCal = 0
        var bobTotalCal = 0
        
        for _ in 0..<alex {
            alextTotalCal  = alextTotalCal + array[alexIndex]
            alexIndex = alexIndex + 1
            
        }
        var bobIndex = alexIndex + 1
        
        
        for _ in 0..<bob {
            bobTotalCal  = bobTotalCal + array[bobIndex]
            bobIndex = bobIndex + 1
            
            
            
        }
        
        return alextTotalCal + bobTotalCal
    }
    
    func longestWord(string:String)-> Int{
        
        var array = string.split(separator: ".");
        var longestValue = 0
        for value in array {
            longestValue = value.split(separator: " ").count
        }
        return longestValue
        
    }
    func sockMerchant(length:Int,array:[Int]) -> Int {
        
        var pairCount = 0
        var tempArray = [Int]()
        
        for element in array {
            if tempArray.contains(element) {
                pairCount = pairCount + 1
                let indexOfA = tempArray.index(of:element)
                tempArray.remove(at: indexOfA!)
            } else {
                tempArray.append(element)
            }
        }
        return pairCount
    }
    
    public func solution2(_ S : String) -> String {
        var periouseValue  = ""
        var copyString = ""
        var index = 0
        for char in S.characters {
            if index == 0 {
                
                copyString =  "\(char)"
            } else {
                if "\(char)" == "A" && (periouseValue != "A" || periouseValue == "")  {
                    copyString = "\(copyString)\(char)"
                } else if "\(char)" == "B" && (periouseValue != "B" || periouseValue == "") {
                    copyString = "\(copyString)\(char)"
                } else if "\(char)" == "C" && (periouseValue != "C" || periouseValue == "") {
                    copyString = "\(copyString)\(char)"
                }
                if copyString.characters.last == char && periouseValue == "\(char)" {
                    copyString.characters.removeLast()
                }
                
            }
            periouseValue = "\(char)"
            index = index + 1
        }
        return copyString
        // write your code in Swift 3.0 (Linux)
    }
    func algo2CheckPerumtation(firstString:String,secondString:String) -> Bool{
        
        if  firstString.count != secondString.count {
            return false
        }
        var firstStringElementsCounts:[String:Int] = [:]
        for element in firstString {
            firstStringElementsCounts["\(element)"] =  (firstStringElementsCounts["\(element)"] ?? 0) + 1
        }
        
        for element in secondString {
            if (firstStringElementsCounts.index(forKey: "\(element)") == nil) {
                return false
            } else if (((firstStringElementsCounts["\(element)"] ?? 0) - 1) < 0) {
                return false
            }
        }
        return true
    }
    
    //    func laneChange(lanes:[Int]) -> Int {
    //
    //        var laneChange = 0
    //        var currentlane = lanes.count/2
    //        var dictionary = lanes.reduce(into: [:]) { counts, number in
    //            counts[number, default: 0] += 1
    //        }
    //        for indexv in 1..<lanes.count+1 {
    //            if lanes.contains(indexv) == false {
    //                dictionary[indexv] = 0
    //            }
    //        }
    //
    //        let minObstacles = dictionary.min { a, b in a.value < b.value }
    //        for element in lanes {
    //
    //            if element == currentlane {
    //                if (currentlane + 1) == minObstacles?.key ?? (lanes.count/2) || (currentlane -1) == minObstacles?.key ?? (lanes.count/2) {
    //                    currentlane = minObstacles?.key ?? lanes.count/2
    //                } else {
    //                    currentlane = currentlane + 1
    //                }
    //                currentlane = minObstacles?.key ?? (lanes.count/2)
    //                laneChange = laneChange + 1
    //            }
    //
    //        }
    //        return laneChange
    //    }
    
    
    public func solution(_ T : [String], _ R :  [String]) -> Int {
        // write your code in Swift 3.0 (Linux)
        var result = 0
        var currentIndex = 0
        var groupArray = [Int]()
        var groupAlreadyFailed = [Int]()
        for indexv in 1..<T.count {
            var groupPassed = false
            for element in T {
                if element.contains("\(indexv)") && groupAlreadyFailed.contains(indexv) == false {
                    if groupArray.contains(indexv) == false {
                        groupArray.append(indexv)
                    }
                    // totalNumberOfgroup = totalNumberOfgroup + 1
                    let indexOfA = T.index(of: element)
                    
                    if let indx = indexOfA {
                        if R[indx] == "OK" {
                            groupPassed = true
                        } else {
                            groupAlreadyFailed.append(indexv)
                            groupPassed = false
                            //break
                        }
                    }
                } else {
                    //break
                }
                currentIndex = currentIndex + 1
            }
            currentIndex = 0
            if groupPassed {
                result = result + 1
            }
        }
        
        return (result * (100/groupArray.count))
        
    }
    func checkUniqueString() {
        let str = "Helo"
        
        var dictionary:[String:Int] = [:]
        var flag = false
        //dictionary["waqas"] = 1
        
        for chr in str {
            if (dictionary.index(forKey: "\(chr)") != nil) {
                flag = true
            } else {
                dictionary["\(chr)"] =  (dictionary["\(chr)"] ?? 0) + 1
            }
        }
        
        if flag == true {
            print("NOt Unique")
        } else {
            print("Unique")
        }
        
        print(dictionary)
    }
    
    func add20ToSpace(inputString:String,trueLength:Int)->String{
        
        let trimmedInputString = inputString.prefix(trueLength)
        let outputString:String = trimmedInputString.replacingOccurrences(of: " ", with: "%20")
        
        return outputString
    }
    func onwayString(inputString:String,secondString:String) -> Bool {
        var count = 0
        for indexv in 0..<inputString.count {
            if inputString[indexv] == secondString[indexv] {
                
            } else {
                count = count + 1
                if count > 1 {
                    return false
                }
            }
        }
        
        return true
        
    }
    func applicationWillResignActive(_ application: UIApplication) {
        // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.
    }
    
    func applicationDidEnterBackground(_ application: UIApplication) {
        // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
    }
    
    func applicationWillEnterForeground(_ application: UIApplication) {
        // Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.
    }
    
    func applicationDidBecomeActive(_ application: UIApplication) {
        // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
    }
    
    func applicationWillTerminate(_ application: UIApplication) {
        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
    }
    
    
}

extension String {
    subscript(i: Int) -> String {
        return String(self[index(startIndex, offsetBy: i)])
    }
}
